<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Grok Voice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', sans-serif;
            background: #000;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            text-align: center;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
        }

        .logo {
            font-size: 3rem;
            font-weight: 600;
            letter-spacing: -0.02em;
            margin-bottom: 4rem;
        }

        .voice-button {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: none;
            background: #fff;
            cursor: pointer;
            position: relative;
            transition: all 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
        }

        .voice-button:hover {
            transform: scale(1.05);
        }

        .voice-button:active {
            transform: scale(0.97);
        }

        .voice-button.connecting {
            animation: pulse-white 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        .voice-button.listening {
            animation: pulse-white 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        .voice-button.speaking {
            animation: pulse-white 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse-white {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4);
            }
            50% {
                box-shadow: 0 0 0 30px rgba(255, 255, 255, 0);
            }
        }

        .mic-icon {
            width: 50px;
            height: 50px;
            fill: #000;
        }

        .status {
            margin-top: 3rem;
            font-size: 1rem;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.6);
            min-height: 1.5rem;
            letter-spacing: -0.01em;
        }

        .error-message {
            background: rgba(255, 59, 48, 0.15);
            border: 1px solid rgba(255, 59, 48, 0.3);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            margin-top: 2rem;
            color: #ff453a;
            font-size: 0.9rem;
        }

        /* 移动端优化 */
        @media (max-width: 480px) {
            .logo {
                font-size: 2.5rem;
            }
            
            .voice-button {
                width: 120px;
                height: 120px;
            }

            .mic-icon {
                width: 42px;
                height: 42px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="logo">Grok Voice</h1>

        <button class="voice-button" id="voiceButton" onclick="toggleVoice()">
            <svg class="mic-icon" viewBox="0 0 24 24" id="buttonIcon">
                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1-9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V5z"/>
                <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
            </svg>
        </button>

        <div class="status" id="status"></div>

        <div class="error-message" id="errorMessage" style="display: none;"></div>
    </div>

    <script>
        // ==================== 配置 ====================
        const CONFIG = {
            // 替换为你的 token 服务地址
            tokenEndpoint: 'https://grok.lucianlee.space/token',
            // Grok Realtime API WebSocket 地址
            wsEndpoint: 'wss://api.x.ai/v1/realtime',
            // 语音设置
            voice: 'Eve',
            // 音频设置
            sampleRate: 24000,
            // Session 配置
            instructions: `You are Grok, a helpful and friendly AI assistant created by xAI. 
You have access to real-time information through web search and X (Twitter) search.
Respond naturally in the same language the user speaks.
Be concise but helpful. Use a warm and engaging tone.`,
        };

        // ==================== 状态管理 ====================
        let state = {
            isConnected: false,
            isListening: false,
            isSpeaking: false,
            websocket: null,
            audioContext: null,
            mediaStream: null,
            audioWorklet: null,
            playbackQueue: [],
            isPlaying: false,
        };

        // ==================== DOM 元素 ====================
        const voiceButton = document.getElementById('voiceButton');
        const statusEl = document.getElementById('status');
        const errorMessage = document.getElementById('errorMessage');
        const buttonIcon = document.getElementById('buttonIcon');

        // ==================== 主要功能 ====================

        async function toggleVoice() {
            if (state.isConnected) {
                disconnect();
            } else {
                await connect();
            }
        }

        async function connect() {
            try {
                updateStatus('connecting', '连接中');
                hideError();

                // 1. 获取 ephemeral token
                const token = await getEphemeralToken();

                // 2. 请求麦克风权限
                await initAudio();

                // 3. 建立 WebSocket 连接
                await connectWebSocket(token);

                // 4. 配置 session
                await configureSession();

                state.isConnected = true;
                state.isListening = true;
                updateStatus('listening', '聆听中');

            } catch (error) {
                console.error('Connection failed:', error);
                showError(error.message);
                disconnect();
            }
        }

        function disconnect() {
            // 关闭 WebSocket
            if (state.websocket) {
                state.websocket.close();
                state.websocket = null;
            }

            // 停止音频
            if (state.mediaStream) {
                state.mediaStream.getTracks().forEach(track => track.stop());
                state.mediaStream = null;
            }

            if (state.audioContext) {
                state.audioContext.close();
                state.audioContext = null;
            }

            // 重置状态
            state.isConnected = false;
            state.isListening = false;
            state.isSpeaking = false;
            state.playbackQueue = [];
            state.isPlaying = false;

            updateStatus('disconnected', '');
        }

        // ==================== Token 获取 ====================

        async function getEphemeralToken() {
            const response = await fetch(CONFIG.tokenEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
            });

            if (!response.ok) {
                throw new Error('获取 token 失败');
            }

            const data = await response.json();
            
            if (!data.value) {
                throw new Error('Token 格式错误');
            }

            return data.value;
        }

        // ==================== 音频初始化 ====================

        async function initAudio() {
            // 请求麦克风权限
            state.mediaStream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    sampleRate: CONFIG.sampleRate,
                    channelCount: 1,
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                }
            });

            // 创建 AudioContext
            state.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: CONFIG.sampleRate,
            });

            // 如果被暂停，恢复 AudioContext
            if (state.audioContext.state === 'suspended') {
                await state.audioContext.resume();
            }
        }

        // ==================== WebSocket 连接 ====================

        async function connectWebSocket(token) {
            return new Promise((resolve, reject) => {
                const ws = new WebSocket(CONFIG.wsEndpoint, [
                    'realtime',
                    `openai-insecure-api-key.${token}`,
                    'openai-beta.realtime-v1'
                ]);

                ws.onopen = () => {
                    console.log('WebSocket connected');
                    state.websocket = ws;
                    resolve();
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    reject(new Error('连接失败'));
                };

                ws.onclose = (event) => {
                    console.log('WebSocket closed:', event.code, event.reason);
                    if (state.isConnected) {
                        disconnect();
                    }
                };

                ws.onmessage = (event) => {
                    handleServerEvent(JSON.parse(event.data));
                };

                // 超时处理
                setTimeout(() => {
                    if (ws.readyState !== WebSocket.OPEN) {
                        ws.close();
                        reject(new Error('连接超时'));
                    }
                }, 10000);
            });
        }

        // ==================== Session 配置 ====================

        async function configureSession() {
            const sessionConfig = {
                type: 'session.update',
                session: {
                    voice: CONFIG.voice,
                    instructions: CONFIG.instructions,
                    turn_detection: {
                        type: 'server_vad',
                        threshold: 0.5,
                        prefix_padding_ms: 300,
                        silence_duration_ms: 500,
                    },
                    audio: {
                        input: {
                            format: { type: 'audio/pcm', rate: CONFIG.sampleRate }
                        },
                        output: {
                            format: { type: 'audio/pcm', rate: CONFIG.sampleRate }
                        }
                    },
                    tools: [
                        { type: 'web_search' },
                        { type: 'x_search' }
                    ]
                }
            };

            sendEvent(sessionConfig);

            // 开始发送音频
            startAudioCapture();
        }

        // ==================== 音频采集 ====================

        function startAudioCapture() {
            const source = state.audioContext.createMediaStreamSource(state.mediaStream);
            const processor = state.audioContext.createScriptProcessor(4096, 1, 1);

            processor.onaudioprocess = (event) => {
                if (!state.isConnected || !state.websocket) return;

                console.log('Sending audio chunk');

                const inputData = event.inputBuffer.getChannelData(0);
                
                // Float32 -> Int16 PCM
                const pcmData = new Int16Array(inputData.length);
                for (let i = 0; i < inputData.length; i++) {
                    const s = Math.max(-1, Math.min(1, inputData[i]));
                    pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                }

                // Base64 编码并发送
                const base64Audio = arrayBufferToBase64(pcmData.buffer);
                sendEvent({
                    type: 'input_audio_buffer.append',
                    audio: base64Audio
                });
            };

            source.connect(processor);
            processor.connect(state.audioContext.destination);
        }

        // ==================== 服务器事件处理 ====================

        function handleServerEvent(event) {
            console.log('Server event:', event.type, event);
            switch (event.type) {
                case 'session.created':
                    console.log('Session created:', event.session?.id);
                    break;

                case 'session.updated':
                    console.log('Session updated');
                    break;

                case 'input_audio_buffer.speech_started':
                    state.isListening = true;
                    state.isSpeaking = false;
                    updateStatus('listening', '聆听中');
                    stopPlayback();
                    break;

                case 'input_audio_buffer.speech_stopped':
                    updateStatus('connected', '思考中');
                    break;

                case 'response.audio.delta':
                    if (event.delta) {
                        queueAudio(event.delta);
                    }
                    break;

                case 'response.audio.done':
                    break;

                case 'response.created':
                    state.isSpeaking = true;
                    updateStatus('speaking', '回复中');
                    break;

                case 'response.done':
                    if (!state.isPlaying) {
                        state.isSpeaking = false;
                        state.isListening = true;
                        updateStatus('listening', '聆听中');
                    }
                    break;

                case 'error':
                    console.error('Server error:', event.error);
                    showError(event.error?.message || '服务器错误');
                    break;
            }
        }

        // ==================== 音频播放 ====================

        function queueAudio(base64Audio) {
            const pcmData = base64ToInt16Array(base64Audio);
            state.playbackQueue.push(pcmData);

            if (!state.isPlaying) {
                playNextChunk();
            }
        }

        async function playNextChunk() {
            if (state.playbackQueue.length === 0) {
                state.isPlaying = false;
                if (state.isConnected && !state.isSpeaking) {
                    state.isListening = true;
                    updateStatus('listening', '聆听中');
                }
                return;
            }

            state.isPlaying = true;
            const pcmData = state.playbackQueue.shift();

            // Int16 -> Float32
            const floatData = new Float32Array(pcmData.length);
            for (let i = 0; i < pcmData.length; i++) {
                floatData[i] = pcmData[i] / 0x8000;
            }

            // 创建并播放 AudioBuffer
            const audioBuffer = state.audioContext.createBuffer(1, floatData.length, CONFIG.sampleRate);
            audioBuffer.getChannelData(0).set(floatData);

            const source = state.audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(state.audioContext.destination);
            source.onended = () => playNextChunk();
            source.start();
        }

        function stopPlayback() {
            state.playbackQueue = [];
            state.isPlaying = false;
        }

        // ==================== 工具函数 ====================

        function sendEvent(event) {
            if (state.websocket && state.websocket.readyState === WebSocket.OPEN) {
                state.websocket.send(JSON.stringify(event));
            }
        }

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToInt16Array(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return new Int16Array(bytes.buffer);
        }

        // ==================== UI 更新 ====================

        function updateStatus(statusType, message) {
            statusEl.textContent = message;

            // 更新按钮样式
            voiceButton.className = 'voice-button';
            if (statusType === 'connecting') {
                voiceButton.classList.add('connecting');
            } else if (statusType === 'listening') {
                voiceButton.classList.add('listening');
            } else if (statusType === 'speaking') {
                voiceButton.classList.add('speaking');
            }

            // 更新图标
            if (statusType === 'disconnected') {
                buttonIcon.innerHTML = `
                    <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1-9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V5z"/>
                    <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                `;
            } else {
                // 连接状态下显示停止图标
                buttonIcon.innerHTML = `
                    <rect x="6" y="6" width="12" height="12" rx="2"/>
                `;
            }
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        function hideError() {
            errorMessage.style.display = 'none';
        }

        // ==================== 页面卸载清理 ====================

        window.addEventListener('beforeunload', () => {
            disconnect();
        });
    </script>
</body>
</html>