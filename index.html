<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Grok Voice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', sans-serif;
            background: #000;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            text-align: center;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
        }

        .logo {
            font-size: 3rem;
            font-weight: 600;
            letter-spacing: -0.02em;
            margin-bottom: 4rem;
        }

        .voice-button {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: none;
            background: #fff;
            cursor: pointer;
            position: relative;
            transition: all 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
        }

        .voice-button:hover {
            transform: scale(1.05);
        }

        .voice-button:active {
            transform: scale(0.97);
        }

        .voice-button.connecting {
            animation: pulse-white 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        .voice-button.listening {
            animation: pulse-white 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        .voice-button.speaking {
            animation: pulse-white 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse-white {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4);
            }
            50% {
                box-shadow: 0 0 0 30px rgba(255, 255, 255, 0);
            }
        }

        .mic-icon {
            width: 50px;
            height: 50px;
            fill: #000;
        }

        .status {
            margin-top: 3rem;
            font-size: 1rem;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.6);
            min-height: 1.5rem;
            letter-spacing: -0.01em;
        }

        .error-message {
            background: rgba(255, 59, 48, 0.15);
            border: 1px solid rgba(255, 59, 48, 0.3);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            margin-top: 2rem;
            color: #ff453a;
            font-size: 0.9rem;
        }

        @media (max-width: 480px) {
            .logo {
                font-size: 2.5rem;
            }
            
            .voice-button {
                width: 120px;
                height: 120px;
            }

            .mic-icon {
                width: 42px;
                height: 42px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="logo">Grok Voice</h1>

        <button class="voice-button" id="voiceButton" onclick="toggleVoice()">
            <svg class="mic-icon" viewBox="0 0 24 24" id="buttonIcon">
                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1-9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V5z"/>
                <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
            </svg>
        </button>

        <div class="status" id="status"></div>

        <div class="error-message" id="errorMessage" style="display: none;"></div>
    </div>

    <script>
        // ==================== 配置 ====================
        const CONFIG = {
            tokenEndpoint: 'https://grok.lucianlee.space/token',
            wsEndpoint: 'wss://api.x.ai/v1/realtime',
            voice: 'Eve',
            sampleRate: 24000,
            instructions: `You are Grok, a helpful and friendly AI assistant created by xAI. 
You have access to real-time information through web search and X (Twitter) search.
Respond naturally in the same language the user speaks.
Be concise but helpful. Use a warm and engaging tone.`,
        };

        // ==================== 状态管理 ====================
        let state = {
            isConnected: false,
            isListening: false,
            isSpeaking: false,
            websocket: null,
            audioContext: null,
            mediaStream: null,
            sourceNode: null,
            workletNode: null,
            playbackQueue: [],
            isPlaying: false,
        };

        // ==================== DOM 元素 ====================
        const voiceButton = document.getElementById('voiceButton');
        const statusEl = document.getElementById('status');
        const errorMessage = document.getElementById('errorMessage');
        const buttonIcon = document.getElementById('buttonIcon');

        // ==================== AudioWorklet 处理器代码 ====================
        const workletCode = `
            class AudioProcessor extends AudioWorkletProcessor {
                constructor() {
                    super();
                    this.bufferSize = 2048;
                    this.buffer = new Float32Array(this.bufferSize);
                    this.bufferIndex = 0;
                }

                process(inputs, outputs, parameters) {
                    const input = inputs[0];
                    if (input && input[0]) {
                        const inputData = input[0];
                        
                        for (let i = 0; i < inputData.length; i++) {
                            this.buffer[this.bufferIndex++] = inputData[i];
                            
                            if (this.bufferIndex >= this.bufferSize) {
                                // 转换为 Int16
                                const pcmData = new Int16Array(this.bufferSize);
                                for (let j = 0; j < this.bufferSize; j++) {
                                    const s = Math.max(-1, Math.min(1, this.buffer[j]));
                                    pcmData[j] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                                }
                                
                                this.port.postMessage(pcmData.buffer, [pcmData.buffer]);
                                this.buffer = new Float32Array(this.bufferSize);
                                this.bufferIndex = 0;
                            }
                        }
                    }
                    return true;
                }
            }
            registerProcessor('audio-processor', AudioProcessor);
        `;

        // ==================== 主要功能 ====================

        async function toggleVoice() {
            if (state.isConnected) {
                disconnect();
            } else {
                await connect();
            }
        }

        async function connect() {
            try {
                updateStatus('connecting', '连接中');
                hideError();

                const token = await getEphemeralToken();
                await initAudio();
                await connectWebSocket(token);
                await configureSession();

                state.isConnected = true;
                state.isListening = true;
                updateStatus('listening', '聆听中');

            } catch (error) {
                console.error('Connection failed:', error);
                showError(error.message);
                disconnect();
            }
        }

        function disconnect() {
            if (state.websocket) {
                state.websocket.close();
                state.websocket = null;
            }

            if (state.workletNode) {
                state.workletNode.disconnect();
                state.workletNode = null;
            }

            if (state.sourceNode) {
                state.sourceNode.disconnect();
                state.sourceNode = null;
            }

            if (state.mediaStream) {
                state.mediaStream.getTracks().forEach(track => track.stop());
                state.mediaStream = null;
            }

            if (state.audioContext) {
                state.audioContext.close();
                state.audioContext = null;
            }

            state.isConnected = false;
            state.isListening = false;
            state.isSpeaking = false;
            state.playbackQueue = [];
            state.isPlaying = false;

            updateStatus('disconnected', '');
        }

        // ==================== Token 获取 ====================

        async function getEphemeralToken() {
            const response = await fetch(CONFIG.tokenEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
            });

            if (!response.ok) {
                throw new Error('获取 token 失败');
            }

            const data = await response.json();
            
            if (!data.value) {
                throw new Error('Token 格式错误');
            }

            return data.value;
        }

        // ==================== 音频初始化 ====================

        async function initAudio() {
            state.mediaStream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    sampleRate: CONFIG.sampleRate,
                    channelCount: 1,
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                }
            });

            state.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: CONFIG.sampleRate,
            });

            if (state.audioContext.state === 'suspended') {
                await state.audioContext.resume();
            }

            // 创建 AudioWorklet
            const blob = new Blob([workletCode], { type: 'application/javascript' });
            const workletUrl = URL.createObjectURL(blob);
            await state.audioContext.audioWorklet.addModule(workletUrl);
            URL.revokeObjectURL(workletUrl);

            state.workletNode = new AudioWorkletNode(state.audioContext, 'audio-processor');
            state.sourceNode = state.audioContext.createMediaStreamSource(state.mediaStream);

            // 处理 worklet 发来的音频数据
            state.workletNode.port.onmessage = (event) => {
                if (state.isConnected && state.websocket && state.websocket.readyState === WebSocket.OPEN) {
                    const base64Audio = arrayBufferToBase64(event.data);
                    sendEvent({
                        type: 'input_audio_buffer.append',
                        audio: base64Audio
                    });
                }
            };

            state.sourceNode.connect(state.workletNode);
            // 不连接到 destination，避免回声
        }

        // ==================== WebSocket 连接 ====================

        async function connectWebSocket(token) {
            return new Promise((resolve, reject) => {
                const ws = new WebSocket(CONFIG.wsEndpoint, [
                    'realtime',
                    `openai-insecure-api-key.${token}`,
                    'openai-beta.realtime-v1'
                ]);

                ws.onopen = () => {
                    console.log('WebSocket connected');
                    state.websocket = ws;
                    resolve();
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    reject(new Error('连接失败'));
                };

                ws.onclose = (event) => {
                    console.log('WebSocket closed:', event.code, event.reason);
                    if (state.isConnected) {
                        disconnect();
                    }
                };

                ws.onmessage = (event) => {
                    handleServerEvent(JSON.parse(event.data));
                };

                setTimeout(() => {
                    if (ws.readyState !== WebSocket.OPEN) {
                        ws.close();
                        reject(new Error('连接超时'));
                    }
                }, 10000);
            });
        }

        // ==================== Session 配置 ====================

        async function configureSession() {
            const sessionConfig = {
                type: 'session.update',
                session: {
                    voice: CONFIG.voice,
                    instructions: CONFIG.instructions,
                    turn_detection: {
                        type: 'server_vad',
                        threshold: 0.5,
                        prefix_padding_ms: 300,
                        silence_duration_ms: 500,
                    },
                    audio: {
                        input: {
                            format: { type: 'audio/pcm', rate: CONFIG.sampleRate }
                        },
                        output: {
                            format: { type: 'audio/pcm', rate: CONFIG.sampleRate }
                        }
                    },
                    tools: [
                        { type: 'web_search' },
                        { type: 'x_search' }
                    ]
                }
            };

            sendEvent(sessionConfig);
        }

        // ==================== 服务器事件处理 ====================

        function handleServerEvent(event) {
            console.log('Server event:', event.type, event);

            switch (event.type) {
                case 'session.created':
                    console.log('Session created:', event.session?.id);
                    break;

                case 'session.updated':
                    console.log('Session updated');
                    break;

                case 'input_audio_buffer.speech_started':
                    state.isListening = true;
                    state.isSpeaking = false;
                    updateStatus('listening', '聆听中');
                    stopPlayback();
                    break;

                case 'input_audio_buffer.speech_stopped':
                    updateStatus('connected', '思考中');
                    break;

                case 'response.audio.delta':
                    if (event.delta) {
                        queueAudio(event.delta);
                    }
                    break;

                case 'response.audio.done':
                    break;

                case 'response.created':
                    state.isSpeaking = true;
                    updateStatus('speaking', '回复中');
                    break;

                case 'response.done':
                    if (!state.isPlaying) {
                        state.isSpeaking = false;
                        state.isListening = true;
                        updateStatus('listening', '聆听中');
                    }
                    break;

                case 'error':
                    console.error('Server error:', event.error);
                    showError(event.error?.message || '服务器错误');
                    break;
            }
        }

        // ==================== 音频播放 ====================

        function queueAudio(base64Audio) {
            const pcmData = base64ToInt16Array(base64Audio);
            state.playbackQueue.push(pcmData);

            if (!state.isPlaying) {
                playNextChunk();
            }
        }

        async function playNextChunk() {
            if (state.playbackQueue.length === 0) {
                state.isPlaying = false;
                if (state.isConnected && !state.isSpeaking) {
                    state.isListening = true;
                    updateStatus('listening', '聆听中');
                }
                return;
            }

            state.isPlaying = true;
            const pcmData = state.playbackQueue.shift();

            const floatData = new Float32Array(pcmData.length);
            for (let i = 0; i < pcmData.length; i++) {
                floatData[i] = pcmData[i] / 0x8000;
            }

            const audioBuffer = state.audioContext.createBuffer(1, floatData.length, CONFIG.sampleRate);
            audioBuffer.getChannelData(0).set(floatData);

            const source = state.audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(state.audioContext.destination);
            source.onended = () => playNextChunk();
            source.start();
        }

        function stopPlayback() {
            state.playbackQueue = [];
            state.isPlaying = false;
        }

        // ==================== 工具函数 ====================

        function sendEvent(event) {
            if (state.websocket && state.websocket.readyState === WebSocket.OPEN) {
                state.websocket.send(JSON.stringify(event));
            }
        }

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToInt16Array(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return new Int16Array(bytes.buffer);
        }

        // ==================== UI 更新 ====================

        function updateStatus(statusType, message) {
            statusEl.textContent = message;

            voiceButton.className = 'voice-button';
            if (statusType === 'connecting') {
                voiceButton.classList.add('connecting');
            } else if (statusType === 'listening') {
                voiceButton.classList.add('listening');
            } else if (statusType === 'speaking') {
                voiceButton.classList.add('speaking');
            }

            if (statusType === 'disconnected') {
                buttonIcon.innerHTML = `
                    <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1-9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V5z"/>
                    <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                `;
            } else {
                buttonIcon.innerHTML = `
                    <rect x="6" y="6" width="12" height="12" rx="2"/>
                `;
            }
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        function hideError() {
            errorMessage.style.display = 'none';
        }

        // ==================== 页面卸载清理 ====================

        window.addEventListener('beforeunload', () => {
            disconnect();
        });
    </script>
</body>
</html>
